{"./":{"url":"./","title":"About Me","keywords":"","body":"技术开发笔记 又抛弃了Hexo换成了gitbook,估计后续修改就会比较少了，回归技术的本质，关注内容。 "},"use-gitbook.html":{"url":"use-gitbook.html","title":"GitBook","keywords":"","body":"如何使用GitBook 安装node 安装gitbook-cli:npm install gitbook-cli -g 查看是否安装成功:gitbook -V 创建:gitbook init 本地浏览:gitbook serve 构建:gitbook build "},"design-pattern/":{"url":"design-pattern/","title":"设计模式","keywords":"","body":"设计模式 设计模式基础 设计模式实践 架构相关 "},"design-pattern/design-command.html":{"url":"design-pattern/design-command.html","title":"命令模式","keywords":"","body":"命令模式 "},"design-pattern/design-flyweight.html":{"url":"design-pattern/design-flyweight.html","title":"享元模式","keywords":"","body":"享元模式 "},"design-pattern/design-ocp.html":{"url":"design-pattern/design-ocp.html","title":"开闭原则","keywords":"","body":"开闭原则 开闭原则(Open Closed Principle, OCP) 含义 当应用的需求改变时，在不修改软件实体源代码或二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。 影响 测试 如果软件遵循开闭原则，那么，测试的时候只需要对扩展的功能进行测试就可以了，因为，原来的测试代码仍然可以正常运行。 提高代码的可复用性 粒度越小，被复用的可能性就越大，在面向对象的过程中，根据原子和抽象编程可以提高代码的可复用性。 可以提高软件的可维护性 稳定性高，延续性强，所以，易于扩展和维护。实现方法 可以通过\"抽象约束，封装变化\"来实现开闭原则。 下面是一个简单的渲染系统，大概表示下OCP的实现和使用。 ``` abstract class DisplayObject{ +disply() } class Label{ +disply() } class Sprite{ +disply() } class DisplayManager{ displayObjects } DisplayObject DisplayObject ``` "},"javascript/":{"url":"javascript/","title":"JavaScript","keywords":"","body":"JavaScript整理 javascript基础 javascript高级 常用库 "},"javascript/js-var-let.html":{"url":"javascript/js-var-let.html","title":"var 和 let","keywords":"","body":"let和var let类似var的用法，但是，所声明的变量，只在let命令所在的代码块内有效。 { var a = 10; let b = 10; } console.log(a); //console.log(b); //ERROR: b is not defined 上面的代码中console.log(b)运行会报错，提示b is not defined. 关于变量提升 var命令会发生变量提升的现象，即变量可以在声明之前使用，值为undefined.这有点不和逻辑， 为了修改这种问题，let修改了这种语法行为，它所声明的变量只能在声明后使用，否则会报错。 console.log(c); //undefined var c = 10; console.log(d); //let d = 11; //ReferenceError: d is not defined 暂时性死区 只要块级作用域内存在let命令，它所声明的变量就\"绑定\"(binding)这个区域，不再受外界影响。 let tmp = 123; if (true){ tmp = 'abc';//ReferenceError: tmp is not defined let tmp = 1; } 在代码块内，使用let命令声明变量之前，该变量是不可以用的，这在语法上称之为“暂时性死区”(temporal dead zone , TDZ). 隐蔽的TDZ function bar(x = y , y = 1){ return [x, y]; } console.log(bar(1,2)); 上面的代码应该是会报错的，因为，x在y使用前调用了y,也就是y还没有声明就调用了y.但是某些时候也不报错，跟底层实现有关系。 let x = x;//SyntaxError: Identifier 'x' has already been declared 上面的代码也会报错，因为，调用的时候x还没有声明。 不允许重复声明 let a = 1; let a = 2;//报错 function func(arg){ let arg;//报错 } let不允许在相同的作用域内，重复声明同一个变量。 我在node中测试就没有报错，不过还是避免这种使用为好。 "},"javascript/js-typecheck.html":{"url":"javascript/js-typecheck.html","title":"类型判断","keywords":"","body":"理论上来说js中类型判断是一个不靠谱的东西。 通常用作类型判断的方法:instanceof和typeof。 typeof 返回一个字符串，用来说明变量的数据类型. 返回结果:number, boolean, string, function, object, undefined 通常用typeof判断一个对象是否存在: if(typeof a != 'undefined'){ // do something } if(a){ // do something // a 不存在可能报错 } 局限性: Array,Null等特殊对象使用typeof一律返回object,这个很坑爹。 instanceof 用来判断一个变量是否属于某个对象的实例。 a instanceof b ? console.log(\"true\") : console.log(\"false\"); let a = [1, 2, 3]; console.log(a instanceof Object); // true console.log(a instanceof Array); // true 上面的例子中a instanceof Object和a instanceof Array都是true,这是因为Array是Object的子类. 其他的类型判断 使用contructor判断 [1, 2].__proto__.constructor === Array; // true [1, 2].__proto__.constructor === Object; // false \"str\".__proto__.constructor === String; // true true.__proto__.constructor === Boolean; // true window.testF = function(){console.log(\"testF\")}; // 函数 testF.__proto__.constructor === Function; // true window.testF2 = ()=>console.log('testF2'); // 函数表达式 testF2.__proto__.constructor === Function; // true NaN.__proto__.constructor === Number; // true 1.__proto__; // Uncaught SyntaxError: Invalid or unexpected token {\"a\":1}.__proto__;// Uncaught SyntaxError: Unexpected token ':' 使用Object.prototype.toString.call()判断 Object.prototype.toString.call(NaN) // \"[object Number]\" Object.prototype.toString.call([1,2]) // \"[object Array]\" // 函数表达式 Object.prototype.toString.call(()=>console.log(1)) // \"[object Function]\" // 函数声明 Object.prototype.toString.call(window.testF) // \"[object Function]\" Object.prototype.toString.call(\"str\") // \"[object String]\" Object.prototype.toString.call(1) // \"[object Number]\" Object.prototype.toString.call(null) // \"[object Null]\" 数组特殊判断 这个接口是ES5之后才有的，游戏开发的话，应该没问题，使用的一般是ES5和ES6规范 Array.isArray([]) // true NaN特殊判断 isNaN(number) 测试 function testFunc() { console.log(\"testFunc\"); } let testArr = { \"NaN\": NaN, \"null\": null, \"undefined\": undefined, \"1\": 1, \"[1,2]\": [1, 2], \"testFunc\": testFunc, \"testFunc2\": () => console.log(\"testFunc2\"), \"obj\": { \"a\": 1 }, \"boolean\": true, \"string\": \"strxxxx\" }; for (let k in testArr) { try { console.log(\"typeof ==>\", k, typeof testArr[k]); console.log(\"instanceof Object ==>\", k, testArr[k] instanceof Object); console.log(\"Object.prototype.toString.call() ==>\", k, Object.prototype.toString.call(testArr[k])); console.log(\"constructor ==>\", k, testArr[k].__proto__.constructor); } catch(e){ console.log(e); } console.log(\"\"); } // 下面是输出结果 typeof ==> 1 number instanceof Object ==> 1 false Object.prototype.toString.call() ==> 1 [object Number] constructor ==> 1 function Number() { [native code] } typeof ==> NaN number instanceof Object ==> NaN false Object.prototype.toString.call() ==> NaN [object Number] constructor ==> NaN function Number() { [native code] } typeof ==> null object instanceof Object ==> null false Object.prototype.toString.call() ==> null [object Null] TypeError: Cannot read property '__proto__' of null at Object. (/Users/tu/self/learn/learn-js/test-types/main.js:23:54) at Module._compile (module.js:652:30) at Object.Module._extensions..js (module.js:663:10) at Module.load (module.js:565:32) at tryModuleLoad (module.js:505:12) at Function.Module._load (module.js:497:3) at Function.Module.runMain (module.js:693:10) at startup (bootstrap_node.js:191:16) at bootstrap_node.js:612:3 typeof ==> undefined undefined instanceof Object ==> undefined false Object.prototype.toString.call() ==> undefined [object Undefined] TypeError: Cannot read property '__proto__' of undefined at Object. (/Users/tu/self/learn/learn-js/test-types/main.js:23:54) at Module._compile (module.js:652:30) at Object.Module._extensions..js (module.js:663:10) at Module.load (module.js:565:32) at tryModuleLoad (module.js:505:12) at Function.Module._load (module.js:497:3) at Function.Module.runMain (module.js:693:10) at startup (bootstrap_node.js:191:16) at bootstrap_node.js:612:3 typeof ==> [1,2] object instanceof Object ==> [1,2] true Object.prototype.toString.call() ==> [1,2] [object Array] constructor ==> [1,2] function Array() { [native code] } typeof ==> testFunc function instanceof Object ==> testFunc true Object.prototype.toString.call() ==> testFunc [object Function] constructor ==> testFunc function Function() { [native code] } typeof ==> testFunc2 function instanceof Object ==> testFunc2 true Object.prototype.toString.call() ==> testFunc2 [object Function] constructor ==> testFunc2 function Function() { [native code] } typeof ==> obj object instanceof Object ==> obj true Object.prototype.toString.call() ==> obj [object Object] constructor ==> obj function Object() { [native code] } typeof ==> boolean boolean instanceof Object ==> boolean false Object.prototype.toString.call() ==> boolean [object Boolean] constructor ==> boolean function Boolean() { [native code] } typeof ==> string string instanceof Object ==> string false Object.prototype.toString.call() ==> string [object String] constructor ==> string function String() { [native code] } 结论 js中最好的类型判断方法应该是使用Object.prototype.toString.call()来判断，因为 这种方法能判断大部分类型，唯一不能区分的是NaN和Number,因为NaN也是Number. 我们可以跟isNaN(number)组合使用。 "},"data-struct/":{"url":"data-struct/","title":"数据结构与算法","keywords":"","body":"数据结构与算法 数据结构基础 算法实现 "},"cocoscreator/":{"url":"cocoscreator/","title":"CocosCreator","keywords":"","body":"CocosCreator整理 "},"cocoscreator/modify-cocoscreator-web.html":{"url":"cocoscreator/modify-cocoscreator-web.html","title":"修改CocosCreator预览网页","keywords":"","body":"修改CocosCreator浏览器预览网页 游戏开发中需要做一些屏幕适配，最快的调试方式就是在浏览器中预览调节，但是，CocosCreator的浏览器预览提供的屏幕尺寸不太够，需要添加一些尺寸，再就是，一些大的屏幕尺寸屏幕上是不能完全显示的，所以，添加了canvas缩放的功能。 苹果上的修改方案 预览网页所在的路径: /Applications/CocosCreator2.09.app/Contents/Resources/static/preview-templates 添加新的屏幕尺寸 boot.js 找到下面的代码，直接往数组里添加就好了。 // init device resolutions var devices = [ { name: 'Apple iPad', width: 1024, height: 768, ratio: 2 }, { name: 'Apple iPad Mini', width: 1024, height: 768, ratio: 1 }, { name: 'Apple iPhone 4', width: 320, height: 480, ratio: 2 }, { name: 'Apple iPhone 5', width: 320, height: 568, ratio: 2 }, { name: 'Apple iPhone 6', width: 375, height: 667, ratio: 2 }, { name: 'Apple iPhone 6 Plus', width: 414, height: 736, ratio: 3 }, { name: 'Huawei P9', width: 540, height: 960, ratio: 2}, { name: 'Huawei Mate9 Pro', width: 720, height: 1280, ratio: 2}, { name: 'Goolge Nexus 4', width: 384, height: 640, ratio: 2 }, { name: 'Goolge Nexus 5', width: 360, height: 640, ratio: 3 }, { name: 'Goolge Nexus 6', width: 412, height: 732, ratio: 3.5 }, { name: 'Goolge Nexus 7', width: 960, height: 600, ratio: 2 }, { name: '二比一', width: 400, height: 800, ratio: 2 }, ]; 添加ScaleMode 1) toolbar.jade 添加下面的代码，需要的话可以自己再加新的 span.item(style='font-size: small;') Scale Mode: div.item select#opts-scale-mode option(value='0') 1.0 option(value='1') 0.8 option(value='2') 0.5 option(value='3') 1.5 option(value='4') 2.0 boot.js 添加代码: var optScaleMode = document.getElementById('opts-scale-mode'); function getScale(){ console.log('getScaleMode==>',optScaleMode.value); var idx = parseInt(optScaleMode.value); var select_values = [1.0, 0.8, 0.5, 1.5, 2.0]; if(idx = select_values.length) return 1.0; return select_values[idx]; } // init options // 修改这个方法 function initPreviewOptions () { var defaultDevice = getCookie('device'); var defaultRotate = getCookie('rotate'); var hasDefaultDevice = defaultDevice !== null; var hasDefaultRotate = defaultRotate !== null; if (hasDefaultDevice) { optsDevice.value = parseInt(defaultDevice); } if (hasDefaultRotate && defaultRotate === 'true') { rotated = !rotated; setCSSChecked(btnRotate, rotated); } optsDebugMode.value = getCookie('debugMode') || '1'; setCSSChecked(btnShowFPS, getCookie('showFPS') === 'true'); inputSetFPS.value = '60'; // 添加了这行代码 optScaleMode.value = getCookie('scaleMode') || 1; showSplash(); } // 在onLoad函数中，添加change监听 optScaleMode.addEventListener('change', function(event){ var value = event.target.value; setCookie('scaleMode', value); //cc.debug._resetDebugSetting(parseInt(value)); }); // 修改getEmulatedScreenSize方法, 添加scale缩放 function getEmulatedScreenSize () { var w, h; var s = getScale(); var idx = optsDevice.value; if ( idx === '0' ) { w = designWidth * s; h = designHeight * s; } else { var info = devices[parseInt(idx) - 1]; w = info.width * s; h = info.height * s; } console.log(\"getEmulatedScreenSize\",w, h , s); return { width: rotated ? h : w, height: rotated ? w : h }; } "},"python/":{"url":"python/","title":"Python","keywords":"","body":"python相关 pyenv使用:https://www.jianshu.com/p/3e93311fe6cb venv使用:https://www.jianshu.com/p/ed51e4f42fe7 基础语法 flask 爬虫scrapy venv python -m venv source /bin/active deactivate pip freeze >requirements.txt pip install -r requirements.txt "},"c-sharp/":{"url":"c-sharp/","title":"C#","keywords":"","body":"C#相关 基础语法 高级语法 "},"others/":{"url":"others/","title":"未分类","keywords":"","body":"未分类 "},"others/cmake-tutor.html":{"url":"others/cmake-tutor.html","title":"CMake学习笔记","keywords":"","body":"什么是CMake 编写平台无关的CMakeLists.txt文件来定制整个编译流程，再根据目标用户的平台进一步生成本地化的Makefile和工程文件。 linux下CMake编译流程: 编写CMakeLists.txt 执行命令cmake PATH或者ccmake PATH生成Makefile,其中PATH是CMakeLists.txt所在的目录。 使用make命令进行编译 CMakeLists.txt的语法比较简单，由命令，注释和空格组成，其中命令是不区分大小写。#后的内容被认为是注释。 命令由命令名称，小括号和参数组成，参数之间通过空格进行间隔。 编译单个文件 //main.cc #include #include double power(double base, int exponent){ int result = base; int i; if (exponent == 0){ return 1; } for(i = 1; i # CMakeLists.txt # CMake 最低版本要求 cmake_minimm_required (VERSION 2.8) # 项目信息 project(demo1) # 指定生成目标 add_executable(demo main.cc) 命令介绍: cmake_minimm_required: 指定运行此配置所需要的CMake的最低版本 project: 参数是demo1,表示项目的名称是demo1 add_executable: 将名为main.cc的源文件编译为一个名为demo1的可执行文件 编译: cmake . make 多个源文件 目录: ./demo2 main.cc MathFunctions.cc MathFunctions.h CMakeLists.txt # 设置CMake最低版本号 cmake_minimum_required (VERSION 2.8) # 设置项目名称 project(demo2) # 查找目录下所有的源文件 # 并将名称保存到 DIR_SRCS 变量 aux_source_directory(. DIR_SRCS) # 指定生成目标 add_executable(demo2 ${DIR_SRCS}) aux_source_directory(PATH NAME)读取PATH下的文件保存到NAME变量中. add_executable(OUT_PUT NAME) OUT_PUT输出的文件,NAME需要编译的文件 多个目录多个源文件 在每个目录下都写一个CMakeLists.txt文件来复制编译。 目录: ./demo3 math/ MathFunctions.cc MathFunctions.h main.cc CMakeLists.txt # 设置CMake最低版本号 cmake_minimum_required(VERSION 2.8) # 设置项目名称 project(demo3) # 查找目标目录下所有的文件 # 并将名称保存到DIR_SRCS变量中 aux_source_directory(. DIR_SRCS) # 添加math子目录 add_subdirectory(math) # 指定生成目录 add_executable(demo ${DIR_SRCS}) # 添加链接库 target_link_libraries(demo MathFunctions) math/CMakeLists.txt # 查找当前目录下所有的源文件 # 并添加到DIR_LIB_SRCS变量中 aux_source_directory(. DIR_LIB_SRCS) # 指定生成MathFunctions链接库 add_library(MathFunctions ${DIR_LIB_SRCS}) "},"others/git-commands.html":{"url":"others/git-commands.html","title":"Git命令总结","keywords":"","body":" git init将这个目录修改为git可以管理的仓库 git add file_name添加一个文件, 可以同时添加多个文件git add file_1 file_2 git commit -m \"addxxxxx\"提交一个修改 git status 查看修改状态 git diff file_name 查看修改内容，可以不跟文件名，直接返回所有的修改内容git diff git log 查看提交日志 git log --pretty=oneline 提交日志在一行显示 git reset版本回退 git reset --hard HEAD^回退一个版本 git reset --hard 版本号 回退到指定版本 git reflog 查看所有的commit日志，包括回退版本 git diff HEAD -- readme.txt 查看工作区和版本库中最新版本的区别 git checkout -- readme.txt 放弃工作区的修改 git reset HEAD 方式提交的暂存区的修改, 如果要彻底放弃修改还需要git checkout -- 放弃工作区的修改 git rm 删除文件 git checkout -- 可以直接中版本库中拉下来误删的文件 git remote add origin git@github.com:luningcowboy/learnGit.git 链接远程仓库 git push -u origin master 把本地仓库推送到远程仓库 git clone 将l远程仓库拉取到本地 git checkout -b dev创建dev分支，这个命令相当于运行了git branch dev和git checkout dev git checkout master 切换到master分支 git merge dev 合并dev分支到master git branch -d dev 删除dev分支 git branch 查看已经有的分支 git merge --no-ff -m \"merge --no-ff\" dev 合并分支并禁用Fast forward模式,这样合并的时候会有一个commit,-m后就是合并的日志 git stash 把当前工作现场储藏起来，等以后回复现场后继续工作. git stash list 查看存储的工作列表 恢复工作现场: git stash apply 恢复，git stash drop 删除 git stash pop git stash apply stash@{0} 恢复指定的stash git branch -D 分支没合并的时候强行删除分支 git remote 查看远程仓库的信息 git push origin 推送本地分支到远程 git branch --set-upstream-to=origin/dev dev 绑定本地dev分支和远程dev分支 git pull 下拉最新的远程分支 git remote -v 查看远程仓库的信息 git log --graph --pretty=oneline --abbrev-commit 查看版本仓库的log, 有图形 git rebase 把分叉的提交历史整理成一条直线，看上去更直观，缺点是本地发分支提交已经被修改过了。 git tag 打版本,方便查找回退 git tag 给指定版本打tag git tag -a v0.1 -m \"version 0.1 released\" 1094adb 创建有说明的tag git tag 查看已经有的tag git show 查看指定的tag信息 git tag -d 删除指定tag git push origin 推送标签到远程仓库 从远程仓库删除tag: 先从本地删除taggit tag -d 从远程仓库删除tag git push origin :refs/tags/ 每一次commit之前都需要先add git reset既可以回退版本，也可以将暂存区的修改回退到工作区 "},"others/svn-cmd-add.html":{"url":"others/svn-cmd-add.html","title":"svn-add批量脚本","keywords":"","body":"ret=`svn stat` echo \"修改的文件:\" echo $ret files=$(svn st | grep ? | sed 's/\\?//g' | sed 's/ //g') echo \"需要添加的文件:\" for i in $files; do svn add $i done "},"others/get-wxgame-code.html":{"url":"others/get-wxgame-code.html","title":"获取微信小游戏源码","keywords":"","body":" 获取小游戏源码包:/data/data/com.tencent.mm/MicroMsg//appbrand/pkg/*.wxapkg 注意: 主要是需要获取小游戏的wxapkg包,之前都是用模拟器，不过微信好像封模拟器了，我用MuMu打不开小游戏，之前是可以的，大家可以试试别的，实在不行只能用真机了，不过真机需要有root权限。 ADB命令大全 当然，如果你有iOS的越狱手机也能获取到wxapkg文件，一样的。 获取解压源码: 解压程序 这个程序是用Node写的，所以需要有Node的环境支持，这个就自己安装吧！ 下面是Node依赖npm install esprima npm install css-tree npm install cssbeautify npm install vm2 npm install uglify-es npm install js-beautify 反编译 node wuWxapkg.js [-d] files是你想要反编译的文件的名字 例如:node wuWxapkg.js test.wxapkg 结束,祝大家破解顺利。 "},"others/git-stash.html":{"url":"others/git-stash.html","title":"git stash","keywords":"","body":"常用git stash命令: git stash save \"save message\":执行存储，报错当前工作区 git stash list: 获取存储列表 git stash show: 显示做了哪些修改，后面添加stash@{$num}, eg: git stash stash@{1} git stash show -p: 显示做了哪些修改，并且显示其他存储，后面添加stash@{$num}, eg: git stash stash@{1} -p git stash apply: 应用某个存储，但是不会把存储从存储列表中删除git stash applyu stash@{num} git stash pop stash@{$num}: 恢复之前缓存的工作目录，并将缓存从存储列表中删除 git stash drop stash@{$num}: 从缓存列表中删除某个存储 git stash clear: 删除所有缓存的stash 注意 新增的文件，直接执行stash是不会被存储的, 不在git仓库中的文件是不能被stash的 参考连接 "},"others/git-tag.html":{"url":"others/git-tag.html","title":"git tag","keywords":"","body":"git tag 新建tag 使用git tag 创建一个新的tag 添加-a参数创建一个有备注的tag,备注信息用-m指定:git tag -a TagName -m \"my tag\" 查看tag详细信息 git show tagName 显示tag列表 git tag git tag -l \"v1.1.*\" 给某个commit添加tag git tag -a v1.1 a512768 -m \"my tag\" 推送tag到远程服务器 推送指定tag:git push origin tagName 推送所有tag:git push origin --tags 切换到某个tag git checkout v1.0.1 这时候不位于任何分支下，处于游离状态，可以基于当前tag创建一个分支 删除某个tag 本地删除: git tag -d v1.0.1 远端删除: git push origin:refs/tags/tagName "}}